# bot.py ‚Äî Telegram-–±–æ—Ç: —É–ø–∞–∫–æ–≤–∫–∞ —Ç–æ–∫–µ–Ω–æ–≤ + —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ (/format)
import os
import logging
from pathlib import Path

from telegram import Update
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    ConversationHandler,
    ContextTypes,
    filters,
)

from token_packer import pack, normalize_tokens
from text_formatter import process_text  # –Ω–æ–≤—ã–π –º–æ–¥—É–ª—å

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# –°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è "—É–ø–∞–∫–æ–≤—â–∏–∫–∞"
LEFT, RIGHT, MINLEN, MAXLEN, SEPARATOR = range(5)
# –°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è —Ñ–æ—Ä–º–∞—Ç—Ç–µ—Ä–∞
FMT_TEXT, FMT_N = range(5, 7)


def _auto_wrap_separator(sep: str) -> str:
    s = (sep or "").strip()
    if not s:
        return ") * ("
    if "(" not in s and ")" not in s:
        return f"){s}("
    return s


# ======== –£–ü–ê–ö–û–í–©–ò–ö (—Å—Ç–∞—Ä—ã–π –¥–∏–∞–ª–æ–≥) ========

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–°—Ç–∞—Ä—Ç/–ø–µ—Ä–µ–∑–∞–ø—É—Å–∫ —É–ø–∞–∫–æ–≤—â–∏–∫–∞."""
    context.user_data.clear()
    await update.message.reply_text(
        "–ü—Ä–∏–≤–µ—Ç! –î–∞–≤–∞–π —Å–æ–±–µ—Ä—ë–º —Ç–æ–∫–µ–Ω—ã.\n–í–≤–µ–¥–∏ –õ–ï–í–£–Æ —á–∞—Å—Ç—å (—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫ —Å–ª–æ–≤):"
    )
    return LEFT


async def left_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data["left"] = normalize_tokens([update.message.text])
    if not context.user_data["left"]:
        await update.message.reply_text("–õ–µ–≤–∞—è —á–∞—Å—Ç—å –ø—É—Å—Ç–∞—è. –í–≤–µ–¥–∏—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–Ω–æ —Å–ª–æ–≤–æ:")
        return LEFT
    await update.message.reply_text("–û—Ç–ª–∏—á–Ω–æ! –¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏ –ü–†–ê–í–£–Æ —á–∞—Å—Ç—å (–ø–ª–∞–≤–∞—é—â–∏–π —Å–ø–∏—Å–æ–∫ —Å–ª–æ–≤):")
    return RIGHT


async def right_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data["right"] = normalize_tokens([update.message.text])
    if not context.user_data["right"]:
        await update.message.reply_text("–ü—Ä–∞–≤–∞—è —á–∞—Å—Ç—å –ø—É—Å—Ç–∞—è. –í–≤–µ–¥–∏—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–Ω–æ —Å–ª–æ–≤–æ:")
        return RIGHT
    await update.message.reply_text("–í–≤–µ–¥–∏ –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é –¥–ª–∏–Ω—É –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä 480):")
    return MINLEN


async def minlen_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        context.user_data["min_len"] = int(update.message.text)
    except ValueError:
        await update.message.reply_text("–û—à–∏–±–∫–∞! –í–≤–µ–¥–∏ —á–∏—Å–ª–æ (–Ω–∞–ø—Ä–∏–º–µ—Ä 480):")
        return MINLEN
    await update.message.reply_text("–¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –¥–ª–∏–Ω—É –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä 512):")
    return MAXLEN


async def maxlen_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        context.user_data["max_len"] = int(update.message.text)
    except ValueError:
        await update.message.reply_text("–û—à–∏–±–∫–∞! –í–≤–µ–¥–∏ —á–∏—Å–ª–æ (–Ω–∞–ø—Ä–∏–º–µ—Ä 512):")
        return MAXLEN
    if context.user_data["min_len"] > context.user_data["max_len"]:
        await update.message.reply_text("min_len –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –±–æ–ª—å—à–µ max_len. –í–≤–µ–¥–∏—Ç–µ max_len –µ—â—ë —Ä–∞–∑:")
        return MAXLEN
    await update.message.reply_text(
        "–¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å (–Ω–∞–ø—Ä–∏–º–µ—Ä ')*(' –∏–ª–∏ ')/1(' ‚Äî —Å–∫–æ–±–æ—á–∫–∏ –º–æ–∂–Ω–æ –Ω–µ –ø–∏—Å–∞—Ç—å):"
    )
    return SEPARATOR


async def separator_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    ud = context.user_data
    separator = _auto_wrap_separator(update.message.text)
    ud["separator"] = separator

    try:
        results = pack(ud["left"], ud["right"], ud["min_len"], ud["max_len"], separator)
        out_text = ", ".join(results)

        if len(out_text) > 4000:
            path = f"result_{update.effective_user.id}.txt"
            with open(path, "w", encoding="utf-8") as f:
                f.write(out_text)
            with open(path, "rb") as f:
                await update.message.reply_document(document=f)
            os.remove(path)
        else:
            await update.message.reply_text(out_text)

        lengths = [f"#{i+1}: {len(c)} —Å–∏–º–≤–æ–ª–æ–≤" for i, c in enumerate(results)]
        await update.message.reply_text("\n".join(lengths))

    except Exception as e:
        logger.exception("–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–ø–∞–∫–æ–≤–∫–µ")
        await update.message.reply_text(f"–û—à–∏–±–∫–∞: {e}")

    return ConversationHandler.END


# ======== –§–û–†–ú–ê–¢–¢–ï–† –¢–ï–ö–°–¢–ê (/format) ========

async def format_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–°—Ç–∞—Ä—Ç —Ñ–æ—Ä–º–∞—Ç—Ç–µ—Ä–∞: –∂–¥—ë–º .txt –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ —Ç–µ–∫—Å—Ç."""
    # –Ω–µ –æ—á–∏—â–∞–µ–º –≤–µ—Å—å user_data, —á—Ç–æ–±—ã –Ω–µ –º–µ—à–∞—Ç—å –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–º —Å–µ—Å—Å–∏—è–º —É–ø–∞–∫–æ–≤—â–∏–∫–∞
    context.user_data.pop("fmt_text", None)
    await update.message.reply_text(
        "–†–µ–∂–∏–º —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è.\n–ü—Ä–∏—à–ª–∏—Ç–µ .txt —Ñ–∞–π–ª –ò–õ–ò –≤—Å—Ç–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ–º (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é):"
    )
    return FMT_TEXT


async def fmt_text_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ü—Ä–∏–Ω–∏–º–∞–µ–º .txt –∏–ª–∏ —Ç–µ–∫—Å—Ç, —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤ user_data['fmt_text'] –∏ —Å–ø—Ä–∞—à–∏–≤–∞–µ–º N."""
    text: str | None = None

    # –ï—Å–ª–∏ –ø—Ä–∏—Å–ª–∞–ª–∏ –¥–æ–∫—É–º–µ–Ω—Ç .txt
    if update.message.document and update.message.document.mime_type == "text/plain":
        doc = update.message.document
        # –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞ –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π (–Ω–∞–ø—Ä–∏–º–µ—Ä, 5 –ú–ë)
        if doc.file_size and doc.file_size > 5 * 1024 * 1024:
            await update.message.reply_text("–§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π (>5 –ú–ë). –ü—Ä–∏—à–ª–∏—Ç–µ –º–µ–Ω—å—à–∏–π —Ñ–∞–π–ª.")
            return FMT_TEXT
        tgfile = await doc.get_file()
        tmp_path = Path(f"upload_{update.effective_user.id}.txt")
        await tgfile.download_to_drive(custom_path=str(tmp_path))
        try:
            text = tmp_path.read_text(encoding="utf-8")
        finally:
            try:
                tmp_path.unlink(missing_ok=True)
            except Exception:
                pass

    # –ï—Å–ª–∏ –ø—Ä–∏—Å–ª–∞–ª–∏ –ø—Ä–æ—Å—Ç–æ —Ç–µ–∫—Å—Ç
    elif update.message.text:
        text = update.message.text

    if not text or not text.strip():
        await update.message.reply_text("–ü—É—Å—Ç–æ–π –≤–≤–æ–¥. –ü—Ä–∏—à–ª–∏—Ç–µ .txt –∏–ª–∏ –≤—Å—Ç–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ–º:")
        return FMT_TEXT

    context.user_data["fmt_text"] = text.strip()
    await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ N –¥–ª—è —Ç–∏–ª—å–¥—ã (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 0):")
    return FMT_N


async def fmt_n_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ü–∞—Ä—Å–∏–º N, —Ñ–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ñ–∞–π–ª –∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É."""
    n_str = (update.message.text or "").strip()
    try:
        n = int(n_str) if n_str else 0
    except ValueError:
        await update.message.reply_text("–û—à–∏–±–∫–∞! –í–≤–µ–¥–∏—Ç–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ N (–Ω–∞–ø—Ä–∏–º–µ—Ä 0, 1, 2):")
        return FMT_N

    text = context.user_data.get("fmt_text", "")
    try:
        result, total, phrases, singles = process_text(text, n)

        # —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤–æ –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º
        out_path = Path(f"formatted_{update.effective_user.id}.txt")
        out_path.write_text(result, encoding="utf-8")
        try:
            with open(out_path, "rb") as f:
                await update.message.reply_document(document=f, filename=out_path.name)
        finally:
            try:
                out_path.unlink(missing_ok=True)
            except Exception:
                pass

        # —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        preview = result[:200]
        await update.message.reply_text(
            f"–ì–æ—Ç–æ–≤–æ ‚úÖ\n–í—Å–µ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤: {total}\n–§—Ä–∞–∑: {phrases}\n–û–¥–∏–Ω–æ—á–Ω—ã—Ö —Å–ª–æ–≤: {singles}\n–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä: {preview}"
        )

    except Exception as e:
        logger.exception("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏")
        await update.message.reply_text(f"–û—à–∏–±–∫–∞: {e}")

    # –∑–∞–≤–µ—Ä—à–∞–µ–º –¥–∏–∞–ª–æ–≥ —Ñ–æ—Ä–º–∞—Ç—Ç–µ—Ä–∞
    context.user_data.pop("fmt_text", None)
    return ConversationHandler.END


# ======== –û–±—â–∏–µ –∫–æ–º–∞–Ω–¥—ã ========

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data.clear()
    await update.message.reply_text("‚õî –û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.")
    return ConversationHandler.END


async def reset(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data.clear()
    await update.message.reply_text("üîÅ –°–±—Ä–æ—Å–∏–ª —Ç–µ–∫—É—â—É—é —Å–µ—Å—Å–∏—é. –ù–∞—á–Ω—ë–º –∑–∞–Ω–æ–≤–æ.\n–í–≤–µ–¥–∏ –õ–ï–í–£–Æ —á–∞—Å—Ç—å:")
    return LEFT


async def on_error(update: object, context: ContextTypes.DEFAULT_TYPE):
    logger.exception("Unhandled exception", exc_info=context.error)


def build_app() -> Application:
    token = os.getenv("BOT_TOKEN")
    if not token:
        raise RuntimeError("BOT_TOKEN is not set")

    app = Application.builder().token(token).build()

    # –î–∏–∞–ª–æ–≥ "—É–ø–∞–∫–æ–≤—â–∏–∫–∞"
    conv_pack = ConversationHandler(
        entry_points=[CommandHandler("start", start)],
        states={
            LEFT: [MessageHandler(filters.TEXT & ~filters.COMMAND, left_input)],
            RIGHT: [MessageHandler(filters.TEXT & ~filters.COMMAND, right_input)],
            MINLEN: [MessageHandler(filters.TEXT & ~filters.COMMAND, minlen_input)],
            MAXLEN: [MessageHandler(filters.TEXT & ~filters.COMMAND, maxlen_input)],
            SEPARATOR: [MessageHandler(filters.TEXT & ~filters.COMMAND, separator_input)],
        },
        fallbacks=[
            CommandHandler("cancel", cancel),
            CommandHandler("reset", reset),
            CommandHandler("start", start),
        ],
        allow_reentry=True,
        conversation_timeout=600,
        name="conv_pack",
        persistent=False,
    )

    # –î–∏–∞–ª–æ–≥ "—Ñ–æ—Ä–º–∞—Ç—Ç–µ—Ä–∞"
    conv_fmt = ConversationHandler(
        entry_points=[CommandHandler("format", format_start)],
        states={
            FMT_TEXT: [
                # –ø—Ä–∏–Ω–∏–º–∞–µ–º .txt —Ñ–∞–π–ª –∏–ª–∏ –æ–±—ã—á–Ω—ã–π —Ç–µ–∫—Å—Ç
                MessageHandler(filters.Document.FileExtension("txt"), fmt_text_input),
                MessageHandler(filters.TEXT & ~filters.COMMAND, fmt_text_input),
            ],
            FMT_N: [MessageHandler(filters.TEXT & ~filters.COMMAND, fmt_n_input)],
        },
        fallbacks=[
            CommandHandler("cancel", cancel),
            CommandHandler("reset", reset),
            CommandHandler("start", start),
        ],
        allow_reentry=True,
        conversation_timeout=600,
        name="conv_fmt",
        persistent=False,
    )

    # –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã
    app.add_handler(CommandHandler("reset", start))
    app.add_handler(conv_fmt)
    app.add_handler(conv_pack)

    app.add_error_handler(on_error)
    return app


def main():
    app = build_app()
    base = os.getenv("WEBHOOK_BASE_URL") or os.getenv("RENDER_EXTERNAL_URL")
    port = int(os.getenv("PORT", "10000"))
    path = f"/webhook/{os.getenv('WEBHOOK_PATH', 'tg')}"
    if base:
        app.run_webhook(
            listen="0.0.0.0",
            port=port,
            url_path=path,
            webhook_url=base.rstrip("/") + path,
        )
    else:
        app.run_polling()


if __name__ == "__main__":
    main()
